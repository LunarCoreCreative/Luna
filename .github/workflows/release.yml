name: Release

on:
  push:
    tags:
      - 'v*'
    branches:
      - main
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0)'
        required: true
        type: string
      prerelease:
        description: 'Mark as pre-release?'
        required: false
        type: boolean
        default: false

jobs:
  release:
    runs-on: windows-latest
    permissions:
      contents: write
      pull-requests: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: npm ci

      - name: Install Python dependencies
        run: |
          cd server
          pip install -r requirements.txt

      - name: Extract version from tag or input
        id: version
        shell: pwsh
        run: |
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $VERSION = "${{ github.event.inputs.version }}"
          } else {
            $VERSION = "${{ github.ref }}" -replace "refs/tags/v", ""
          }
          Write-Host "version=$VERSION" >> $env:GITHUB_OUTPUT
          Write-Host "Extracted version: $VERSION"

      - name: Update package.json version
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.version }}"
          $packageJson = Get-Content package.json -Raw | ConvertFrom-Json
          $packageJson.version = $version
          $json = $packageJson | ConvertTo-Json -Depth 100
          # Salvar sem BOM
          $utf8NoBom = New-Object System.Text.UTF8Encoding $false
          [System.IO.File]::WriteAllText((Resolve-Path package.json), $json, $utf8NoBom)
          Write-Host "Updated package.json to version $version"
          # Verificar se foi atualizado
          $verify = Get-Content package.json -Raw | ConvertFrom-Json
          Write-Host "Verified version in package.json: $($verify.version)"

      - name: Extract changelog
        id: changelog
        run: |
          if (Test-Path CHANGELOG.md) {
            # Extrair seção do changelog para a versão atual
            $version = "${{ steps.version.outputs.version }}"
            $content = Get-Content CHANGELOG.md -Raw
            if ($content -match "(?s)## \[$version\].*?(?=##|$)") {
              $changelog = $matches[0].Trim()
              $changelog = $changelog -replace "## \[$version\]", "## $version"
              $changelog | Out-File -FilePath changelog_release.txt -Encoding utf8
              Write-Host "Changelog extracted"
            } else {
              Write-Host "No changelog entry found for version $version"
              "## $version`n`nRelease notes." | Out-File -FilePath changelog_release.txt -Encoding utf8
            }
          } else {
            Write-Host "CHANGELOG.md not found, using default"
            "## ${{ steps.version.outputs.version }}`n`nRelease notes." | Out-File -FilePath changelog_release.txt -Encoding utf8
          }

      - name: Create GitHub Release (Draft)
        id: create_release
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const changelog = fs.readFileSync('changelog_release.txt', 'utf8');
            const isPrerelease = ${{ github.event.inputs.prerelease || false }};
            
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: `v${{ steps.version.outputs.version }}`,
              name: `Release v${{ steps.version.outputs.version }}`,
              body: changelog,
              draft: true,
              prerelease: isPrerelease
            });
            
            core.setOutput('id', release.data.id);
            core.setOutput('upload_url', release.data.upload_url);

      - name: Verify package.json version
        shell: pwsh
        run: |
          try {
            $content = Get-Content package.json -Raw
            Write-Host "package.json content length: $($content.Length)"
            Write-Host "First 100 chars: $($content.Substring(0, [Math]::Min(100, $content.Length)))"
            
            $pkg = $content | ConvertFrom-Json
            Write-Host "Parsed JSON successfully"
            Write-Host "Version field exists: $($pkg.PSObject.Properties.Name -contains 'version')"
            
            if (-not $pkg.version -or $pkg.version -eq "") {
              Write-Error "Version is missing or empty in package.json!"
              Write-Host "Available properties: $($pkg.PSObject.Properties.Name -join ', ')"
              exit 1
            }
            Write-Host "✓ Version in package.json: $($pkg.version)"
            Write-Host "Expected version: ${{ steps.version.outputs.version }}"
            if ($pkg.version -ne "${{ steps.version.outputs.version }}") {
              Write-Warning "Version mismatch! Expected: ${{ steps.version.outputs.version }}, Got: $($pkg.version)"
            }
          } catch {
            Write-Error "Failed to parse package.json: $_"
            Write-Host "Error details: $($_.Exception.Message)"
            exit 1
          }

      - name: Build application
        shell: pwsh
        run: npm run dist:desktop
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload release assets
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const releaseId = ${{ steps.create_release.outputs.id }};
            const version = '${{ steps.version.outputs.version }}';
            
            // Função para deletar asset existente se houver
            async function deleteExistingAsset(releaseId, assetName) {
              try {
                const assets = await github.rest.repos.listReleaseAssets({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: releaseId
                });
                
                const existingAsset = assets.data.find(asset => asset.name === assetName);
                if (existingAsset) {
                  console.log(`Deleting existing asset: ${assetName} (ID: ${existingAsset.id})`);
                  await github.rest.repos.deleteReleaseAsset({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    asset_id: existingAsset.id
                  });
                  console.log(`✓ Deleted existing asset: ${assetName}`);
                }
              } catch (error) {
                console.log(`No existing asset to delete or error: ${error.message}`);
              }
            }
            
            // Upload installer
            const installerPath = `./release/Luna-${version}-Setup.exe`;
            const installerName = `Luna-${version}-Setup.exe`;
            
            if (fs.existsSync(installerPath)) {
              console.log(`Uploading installer: ${installerName}`);
              
              // Deletar asset existente se houver
              await deleteExistingAsset(releaseId, installerName);
              
              const installerData = fs.readFileSync(installerPath);
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: installerName,
                data: installerData,
                headers: {
                  'content-type': 'application/octet-stream',
                  'content-length': installerData.length
                }
              });
              console.log(`✓ Uploaded installer: ${installerName}`);
            } else {
              console.log(`Installer not found: ${installerPath}`);
            }
            
            // Upload latest.yml
            const latestYmlPath = './release/latest.yml';
            const latestYmlName = 'latest.yml';
            
            if (fs.existsSync(latestYmlPath)) {
              console.log(`Uploading latest.yml`);
              
              // Deletar asset existente se houver
              await deleteExistingAsset(releaseId, latestYmlName);
              
              const latestYmlData = fs.readFileSync(latestYmlPath);
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: latestYmlName,
                data: latestYmlData,
                headers: {
                  'content-type': 'text/yaml',
                  'content-length': latestYmlData.length
                }
              });
              console.log(`✓ Uploaded latest.yml`);
            } else {
              console.log(`latest.yml not found: ${latestYmlPath}`);
            }

      - name: Publish release
        uses: actions/github-script@v7
        with:
          script: |
            const releaseId = ${{ steps.create_release.outputs.id }};
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              draft: false,
              make_latest: ${{ !github.event.inputs.prerelease }}
            });
