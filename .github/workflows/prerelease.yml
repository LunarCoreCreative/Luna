name: Pre-Release (Beta/Alpha)

on:
  push:
    branches:
      - staging
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0-beta.1)'
        required: true
        type: string
      channel:
        description: 'Release channel (beta, alpha, rc)'
        required: false
        type: choice
        options:
          - beta
          - alpha
          - rc
        default: beta

jobs:
  prerelease:
    runs-on: windows-latest
    permissions:
      contents: write
      pull-requests: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: npm ci

      - name: Install Python dependencies
        run: |
          cd server
          pip install -r requirements.txt

      - name: Determine version
        id: version
        shell: pwsh
        run: |
          Write-Host "Determining version..."
          Write-Host "Event name: ${{ github.event_name }}"
          
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $VERSION = "${{ github.event.inputs.version }}"
            Write-Host "Using input version: $VERSION"
          } else {
            # Auto-incrementar pre-release baseado na última tag
            Write-Host "Auto-determining version from tags..."
            $LAST_TAG = git describe --tags --abbrev=0 2>$null
            Write-Host "Last tag: $LAST_TAG"
            
            if (-not $LAST_TAG) { 
              $LAST_TAG = "v0.0.0"
              Write-Host "No tags found, using default: $LAST_TAG"
            }
            
            $LAST_VERSION = $LAST_TAG -replace "^v", ""
            Write-Host "Last version: $LAST_VERSION"
            
            $CHANNEL = "${{ github.event.inputs.channel }}"
            if (-not $CHANNEL -or $CHANNEL -eq "") { 
              $CHANNEL = "beta"
            }
            Write-Host "Channel: $CHANNEL"
            
            # Extrair número base (ex: 1.0.0-beta.1 -> 1.0.0)
            if ($LAST_VERSION -match "^(\d+\.\d+\.\d+)(?:-.*)?$") {
              $BASE_VERSION = $matches[1]
              Write-Host "Base version from tag: $BASE_VERSION"
            } else {
              # Se não conseguir extrair, usar versão do package.json ou padrão
              Write-Host "Could not extract base version from tag, trying package.json..."
              try {
                $pkg = Get-Content package.json -Raw | ConvertFrom-Json
                if ($pkg.version) {
                  $BASE_VERSION = $pkg.version -replace "-.*$", ""
                  Write-Host "Base version from package.json: $BASE_VERSION"
                } else {
                  $BASE_VERSION = "1.0.0"
                  Write-Host "Using default base version: $BASE_VERSION"
                }
              } catch {
                $BASE_VERSION = "1.0.0"
                Write-Host "Error reading package.json, using default: $BASE_VERSION"
              }
            }
            
            # Extrair número do pre-release (ex: beta.1 -> 1)
            if ($LAST_VERSION -match "[a-z]+\.(\d+)$") {
              $PRE_NUM = [int]$matches[1]
              Write-Host "Previous pre-release number: $PRE_NUM"
            } else {
              $PRE_NUM = 0
              Write-Host "No previous pre-release found, starting at 0"
            }
            $NEW_PRE_NUM = $PRE_NUM + 1
            Write-Host "New pre-release number: $NEW_PRE_NUM"
            
            $VERSION = "$BASE_VERSION-$CHANNEL.$NEW_PRE_NUM"
            Write-Host "Calculated version: $VERSION"
          }
          
          # Garantir que a versão não está vazia
          if (-not $VERSION -or $VERSION -eq "" -or $VERSION.Trim() -eq "") {
            Write-Error "Failed to determine version! VERSION variable is empty."
            exit 1
          }
          
          # Escrever no output do GitHub Actions (formato correto para PowerShell)
          $outputLine = "version=$VERSION"
          Add-Content -Path $env:GITHUB_OUTPUT -Value $outputLine
          Write-Host "✓ Written to GITHUB_OUTPUT: $outputLine"
          Write-Host "✓ Determined version: $VERSION"
          
          # Verificar se foi escrito corretamente
          if (Test-Path $env:GITHUB_OUTPUT) {
            $outputContent = Get-Content $env:GITHUB_OUTPUT -Raw
            Write-Host "GITHUB_OUTPUT file content: $outputContent"
          }

      - name: Update package.json version
        shell: pwsh
        run: |
          # Ler a versão do output do step anterior
          $version = "${{ steps.version.outputs.version }}"
          
          Write-Host "Raw version from step output: '$version'"
          
          # Se estiver vazio, tentar ler do arquivo de output do GitHub
          if (-not $version -or $version -eq "" -or $version -eq " ") {
            Write-Host "Version is empty, trying alternative method..."
            # Tentar ler do GITHUB_OUTPUT diretamente
            if (Test-Path $env:GITHUB_OUTPUT) {
              $outputContent = Get-Content $env:GITHUB_OUTPUT -Raw
              Write-Host "GITHUB_OUTPUT content: $outputContent"
              if ($outputContent -match "version=(.+)") {
                $version = $matches[1].Trim()
                Write-Host "Extracted version from GITHUB_OUTPUT: $version"
              }
            }
          }
          
          if (-not $version -or $version -eq "" -or $version -eq " ") {
            Write-Error "Version is empty! Cannot update package.json"
            Write-Host "Debug: steps.version.outputs.version = '${{ steps.version.outputs.version }}'"
            exit 1
          }
          
          Write-Host "Updating package.json to version: $version"
          
          # Ler package.json
          $packageJsonPath = "package.json"
          if (-not (Test-Path $packageJsonPath)) {
            Write-Error "package.json not found!"
            exit 1
          }
          
          # Ler como JSON para obter versão atual
          $pkg = Get-Content $packageJsonPath -Raw | ConvertFrom-Json
          $oldVersion = $pkg.version
          Write-Host "Current version: $oldVersion"
          
          # Ler linhas do arquivo para preservar formatação
          $lines = Get-Content $packageJsonPath
          $found = $false
          $updatedLines = @()
          
          foreach ($line in $lines) {
            # Procurar linha que contém "version"
            if ($line -match '^\s*"version"\s*:\s*"([^"]+)"') {
              # Substituir apenas a versão usando [regex]::Replace
              $newLine = [regex]::Replace($line, '("version"\s*:\s*")[^"]*(")', {
                param($match)
                return $match.Groups[1].Value + $version + $match.Groups[2].Value
              })
              $updatedLines += $newLine
              $found = $true
              Write-Host "Line found: $line"
              Write-Host "Line updated: $newLine"
            } else {
              $updatedLines += $line
            }
          }
          
          if (-not $found) {
            Write-Error "Could not find version line in package.json"
            exit 1
          }
          
          # Salvar arquivo atualizado SEM BOM
          $content = $updatedLines -join "`n"
          $utf8NoBom = New-Object System.Text.UTF8Encoding $false
          [System.IO.File]::WriteAllText((Resolve-Path $packageJsonPath), $content, $utf8NoBom)
          
          # Verificar se o JSON ainda é válido
          try {
            $test = Get-Content $packageJsonPath -Raw | ConvertFrom-Json
            if ($test.version -eq $version) {
              Write-Host "✓ Version updated: $oldVersion -> $version"
            } else {
              throw "Version mismatch! Expected: $version, Got: $($test.version)"
            }
          } catch {
            Write-Error "Error validating package.json: $_"
            exit 1
          }

      - name: Extract changelog
        id: changelog
        run: |
          if (Test-Path CHANGELOG.md) {
            $version = "${{ steps.version.outputs.version }}"
            $content = Get-Content CHANGELOG.md -Raw
            if ($content -match "(?s)## \[$version\].*?(?=##|$)") {
              $changelog = $matches[0].Trim()
              $changelog = $changelog -replace "## \[$version\]", "## $version"
              $changelog | Out-File -FilePath changelog_release.txt -Encoding utf8
              Write-Host "Changelog extracted"
            } else {
              # Usar seção "Não Publicado" se disponível
              if ($content -match "(?s)## \[Não Publicado\].*?(?=##|$)") {
                $changelog = $matches[0].Trim()
                $changelog = $changelog -replace "## \[Não Publicado\]", "## $version (Pre-Release)"
                $changelog | Out-File -FilePath changelog_release.txt -Encoding utf8
                Write-Host "Using 'Não Publicado' section"
              } else {
                Write-Host "No changelog entry found"
                "## $version (Pre-Release)`n`nPre-release build from staging branch." | Out-File -FilePath changelog_release.txt -Encoding utf8
              }
            }
          } else {
            Write-Host "CHANGELOG.md not found"
            "## ${{ steps.version.outputs.version }} (Pre-Release)`n`nPre-release build from staging branch." | Out-File -FilePath changelog_release.txt -Encoding utf8
          }

      - name: Create tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
          git tag -a "v${{ steps.version.outputs.version }}" -m "Pre-release v${{ steps.version.outputs.version }}"
          git push origin "v${{ steps.version.outputs.version }}"

      - name: Create GitHub Release (Draft)
        id: create_release
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const changelog = fs.readFileSync('changelog_release.txt', 'utf8');
            const tagName = `v${{ steps.version.outputs.version }}`;
            
            // Verificar se já existe um release com essa tag
            let existingRelease = null;
            try {
              const releases = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              
              existingRelease = releases.data.find(r => r.tag_name === tagName);
              if (existingRelease) {
                console.log(`Found existing release with tag ${tagName} (ID: ${existingRelease.id})`);
                console.log(`Deleting existing release...`);
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: existingRelease.id
                });
                console.log(`✓ Deleted existing release`);
              }
            } catch (error) {
              // Se não encontrar, continua normalmente
              console.log(`No existing release found or error checking: ${error.message}`);
            }
            
            // Criar novo release
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: `Pre-Release v${{ steps.version.outputs.version }}`,
              body: changelog,
              draft: true,
              prerelease: true
            });
            
            core.setOutput('id', release.data.id);
            core.setOutput('upload_url', release.data.upload_url);

      - name: Verify package.json version
        shell: pwsh
        run: |
          Write-Host "Verifying package.json version..."
          
          if (-not (Test-Path "package.json")) {
            Write-Error "package.json not found!"
            exit 1
          }
          
          try {
            $content = Get-Content package.json -Raw
            Write-Host "package.json content length: $($content.Length)"
            Write-Host "First 100 chars: $($content.Substring(0, [Math]::Min(100, $content.Length)))"
            
            $pkg = $content | ConvertFrom-Json
            Write-Host "Parsed JSON successfully"
            Write-Host "Version field exists: $($pkg.PSObject.Properties.Name -contains 'version')"
            
            if (-not $pkg.PSObject.Properties['version']) {
              Write-Error "Version field is missing in package.json!"
              Write-Host "Available properties: $($pkg.PSObject.Properties.Name -join ', ')"
              exit 1
            }
            
            if (-not $pkg.version -or $pkg.version -eq "") {
              Write-Error "Version is empty in package.json!"
              exit 1
            }
            
            Write-Host "✓ Version in package.json: $($pkg.version)"
            Write-Host "Expected version: ${{ steps.version.outputs.version }}"
            if ($pkg.version -ne "${{ steps.version.outputs.version }}") {
              Write-Warning "Version mismatch! Expected: ${{ steps.version.outputs.version }}, Got: $($pkg.version)"
            }
          } catch {
            Write-Error "Failed to parse package.json: $_"
            Write-Host "Error details: $($_.Exception.Message)"
            exit 1
          }
          
          Write-Host "✓ Version in package.json: $($pkg.version)"

      - name: Build application
        shell: pwsh
        run: npm run dist:desktop
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload release assets
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const releaseId = ${{ steps.create_release.outputs.id }};
            const version = '${{ steps.version.outputs.version }}';
            
            // Função para deletar asset existente se houver
            async function deleteExistingAsset(releaseId, assetName) {
              try {
                const assets = await github.rest.repos.listReleaseAssets({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: releaseId
                });
                
                const existingAsset = assets.data.find(asset => asset.name === assetName);
                if (existingAsset) {
                  console.log(`Deleting existing asset: ${assetName} (ID: ${existingAsset.id})`);
                  await github.rest.repos.deleteReleaseAsset({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    asset_id: existingAsset.id
                  });
                  console.log(`✓ Deleted existing asset: ${assetName}`);
                }
              } catch (error) {
                console.log(`No existing asset to delete or error: ${error.message}`);
              }
            }
            
            // Upload installer
            const installerPath = `./release/Luna-${version}-Setup.exe`;
            const installerName = `Luna-${version}-Setup.exe`;
            
            if (fs.existsSync(installerPath)) {
              console.log(`Uploading installer: ${installerName}`);
              
              // Deletar asset existente se houver
              await deleteExistingAsset(releaseId, installerName);
              
              const installerData = fs.readFileSync(installerPath);
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: installerName,
                data: installerData,
                headers: {
                  'content-type': 'application/octet-stream',
                  'content-length': installerData.length
                }
              });
              console.log(`✓ Uploaded installer: ${installerName}`);
            } else {
              console.log(`Installer not found: ${installerPath}`);
            }
            
            // Upload latest.yml
            const latestYmlPath = './release/latest.yml';
            const latestYmlName = 'latest.yml';
            
            if (fs.existsSync(latestYmlPath)) {
              console.log(`Uploading latest.yml`);
              
              // Deletar asset existente se houver
              await deleteExistingAsset(releaseId, latestYmlName);
              
              const latestYmlData = fs.readFileSync(latestYmlPath);
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: latestYmlName,
                data: latestYmlData,
                headers: {
                  'content-type': 'text/yaml',
                  'content-length': latestYmlData.length
                }
              });
              console.log(`✓ Uploaded latest.yml`);
            } else {
              console.log(`latest.yml not found: ${latestYmlPath}`);
            }

      - name: Publish pre-release
        uses: actions/github-script@v7
        with:
          script: |
            const releaseId = ${{ steps.create_release.outputs.id }};
            const tagName = `v${{ steps.version.outputs.version }}`;
            
            try {
              // Primeiro, verificar o estado atual do release
              const currentRelease = await github.rest.repos.getRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId
              });
              
              // Se já está publicado e no estado correto, não precisa fazer nada
              if (!currentRelease.data.draft && currentRelease.data.prerelease) {
                console.log(`✓ Pre-release already published and in correct state`);
                return;
              }
              
              // Atualizar apenas se necessário
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                draft: false,
                prerelease: true,
                make_latest: false
              });
              console.log(`✓ Pre-release published successfully`);
            } catch (error) {
              console.error(`Error publishing pre-release: ${error.message}`);
              
              // Se o release não foi encontrado, tentar buscar por tag
              if (error.status === 404) {
                console.log(`Release not found by ID, searching by tag...`);
                const releases = await github.rest.repos.listReleases({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                const existingRelease = releases.data.find(r => r.tag_name === tagName);
                if (existingRelease) {
                  console.log(`Found existing release with tag ${tagName}`);
                  // Se já está publicado, não precisa fazer nada
                  if (!existingRelease.draft && existingRelease.prerelease) {
                    console.log(`✓ Pre-release already published and in correct state`);
                    return;
                  }
                  // Atualizar apenas se necessário
                  await github.rest.repos.updateRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: existingRelease.id,
                    draft: false,
                    prerelease: true,
                    make_latest: false
                  });
                  console.log(`✓ Updated existing pre-release successfully`);
                } else {
                  throw new Error(`Release not found by ID or tag`);
                }
              } else if (error.status === 422) {
                // Erro de validação - provavelmente o release já está no estado correto
                const errorMessage = error.response?.data?.message || '';
                const errors = error.response?.data?.errors || [];
                const hasAlreadyExists = errors.some(e => e.code === 'already_exists');
                
                if (hasAlreadyExists) {
                  console.log(`Release with tag ${tagName} already exists`);
                  // Verificar o estado atual
                  try {
                    const releases = await github.rest.repos.listReleases({
                      owner: context.repo.owner,
                      repo: context.repo.repo
                    });
                    const existingRelease = releases.data.find(r => r.tag_name === tagName);
                    if (existingRelease) {
                      if (!existingRelease.draft && existingRelease.prerelease) {
                        console.log(`✓ Pre-release already published and in correct state`);
                        return;
                      } else {
                        console.log(`Release exists but in wrong state (draft: ${existingRelease.draft}, prerelease: ${existingRelease.prerelease})`);
                        // Não tentar atualizar novamente para evitar loop
                        console.log(`Skipping update to avoid validation error`);
                        return;
                      }
                    }
                  } catch (checkError) {
                    console.error(`Error checking release state: ${checkError.message}`);
                  }
                  // Se não conseguimos verificar, assumir que está OK e continuar
                  console.log(`Assuming release is in correct state, continuing...`);
                  return;
                } else {
                  // Outro tipo de erro de validação
                  console.error(`Validation error: ${errorMessage}`);
                  throw error;
                }
              } else {
                throw error;
              }
            }
